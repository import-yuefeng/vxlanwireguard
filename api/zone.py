#!/usr/bin/env python3

# MIT License
#
# Copyright (c) 2018 Star Brilliant
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import encodings.idna
import errno
import ipaddress
import sys
import time
from typing import Any, Dict, List, Optional
from . import common
import argparse


def vw_zone(args: argparse.Namespace) -> int:

    print(';; Generated by VxWireguard-Generator')

    return_value = 0

    for network_name, domain_suffix in zip(args.interface, args.domain):
        # config = common.Config()

        # if not config.load(network_name):
        #     print("vwgen: Unable to find configuration file '{}.conf'".format(
        #         network_name),
        #           file=sys.stderr)
        #     return_value = return_value or errno.ENOENT
        #     continue
        config = args.config

        network_name = config.network_name()
        domain_suffix = encodings.idna.ToASCII(''.join(
            (c for c in domain_suffix.strip('.') + '.'
             if ord(c) > 32))).decode('ascii').lstrip('.')

        network: Dict[str, Any] = config.network()
        nodes: Dict[str, dict] = config.nodes()

        print()
        print(';; Network {}'.format(network_name))
        print('$ORIGIN                         {}'.format(domain_suffix))
        print('$TTL                            300')

        A_records: List[str] = []
        AAAA_records: List[str] = []
        PTR_IP_records: List[str] = []
        PTR_IP6_records: List[str] = []

        for node_name, node in nodes.items():
            safe_node_name = encodings.idna.ToASCII(''.join(
                (c for c in node_name if ord(c) > 32))).decode('ascii')

            addresses: List[str] = node.get('Address', [])

            pubkey_ipv6: Optional[str] = common.generate_pubkey_ipv6(
                network, node)
            if pubkey_ipv6:
                addresses.append(pubkey_ipv6)

            for address in addresses:
                address = address.split('/', 1)[0]
                ip: Optional[ipaddress._BaseAddress] = None

                try:
                    ip = ipaddress.IPv4Address(address)
                except ipaddress.AddressValueError:
                    ip = None

                if ip is None:
                    try:
                        ip = ipaddress.IPv6Address(address)
                    except ipaddress.AddressValueError:
                        pass

                if ip is None:
                    print("vwgen: Invalid IP address '{}'".format(address),
                          file=sys.stderr)
                    return_value = return_value or errno.EADDRNOTAVAIL
                    continue

                if isinstance(ip, ipaddress.IPv4Address):

                    A_records.append('{}300     IN      A       {}'.format(
                        pad_to_tab(safe_node_name + '.' + domain_suffix, 32),
                        ip.compressed))

                    PTR_IP_records.append(
                        '{}300     IN      PTR     {}.{}'.format(
                            pad_to_tab(ip.reverse_pointer + '.', 32),
                            safe_node_name, domain_suffix))

                elif isinstance(ip, ipaddress.IPv6Address):

                    AAAA_records.append('{}300     IN      AAAA    {}'.format(
                        pad_to_tab(safe_node_name + '.' + domain_suffix, 32),
                        ip.compressed))

                    PTR_IP6_records.append(
                        '{}300     IN      PTR     {}.{}'.format(
                            pad_to_tab(ip.reverse_pointer + '.', 80),
                            safe_node_name, domain_suffix))

        print(
            '{}300     IN      SOA     ns1.{} hostmaster.{} {:.0f} 86400 7200 604800 300'
            .format(pad_to_tab(domain_suffix, 32), domain_suffix,
                    domain_suffix, time.time()))

        for line in A_records:
            print(line)

        for line in AAAA_records:
            print(line)

        for line in PTR_IP_records:
            print(line)

        for line in PTR_IP6_records:
            print(line)

        config.close()

    return return_value


def pad_to_tab(s: str, min_width: int) -> str:
    return s.ljust(max(len(s), min_width - 1) // 8 * 8 + 8)
